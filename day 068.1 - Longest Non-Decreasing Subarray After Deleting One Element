/*
# ğŸ§  Problem: Longest Non-Decreasing Subarray After Deleting One Element

## ğŸ“ Description:
You are given an integer array `nums`. You can delete exactly one element from it.  
Your goal is to find the length of the longest non-decreasing subarray you can obtain after performing this deletion.

A non-decreasing subarray means that for every adjacent pair `nums[i]` and `nums[i + 1]`, we have:
nums[i] <= nums[i + 1]

---

### ğŸ” Example:
Input:
nums = [1, 2, 3, 10, 4, 2, 3, 5]

Output:
5

Explanation:
After deleting 10, the array [1, 2, 3, 4, 5] becomes non-decreasing and its length is 5.

---

## ğŸ’¡ Approach:
1. Precompute two arrays:
   - `l[i]`: Length of longest non-decreasing subarray ending at index i.
   - `r[i]`: Length of longest non-decreasing subarray starting at index i.
2. Iterate through the array:
   - Track the maximum length of continuous non-decreasing sequence.
   - Try deleting each element nums[i] and check if connecting l[i-1] and r[i+1] is still non-decreasing.
3. Return the maximum possible answer.

---

## ğŸ§  Time and Space Complexity:
Time Complexity: O(n)
Space Complexity: O(n)
*/

class Solution {
    public int longestSubarray(int[] nums) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        
        l[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] >= nums[i - 1]) {
                l[i] = l[i - 1] + 1;
            } else {
                l[i] = 1;
            }
        }
        
        r[n - 1] = 1;
        for (int j = n - 2; j >= 0; j--) {
            if (nums[j] <= nums[j + 1]) {
                r[j] = r[j + 1] + 1;
            } else {
                r[j] = 1;
            }
        }
        
        int ans = 1;
        for (int i = 0; i < n; i++) {
            ans = Math.max(ans, l[i]);
            if (i > 0 && i < n - 1 && nums[i - 1] <= nums[i + 1]) {
                ans = Math.max(ans, l[i - 1] + r[i + 1]);
            }
        }
        return Math.min(ans + 1, n);
    }
}
