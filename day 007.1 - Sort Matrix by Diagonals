// DAY 7
// QUESTION: leetcode:3446 (Sort Matrix by Diagonals)
//
// You are given an n x n square matrix of integers grid.
// Return the matrix such that:
//
// - The diagonals in the bottom-left triangle (including the main diagonal) 
//   are sorted in non-increasing order.
// - The diagonals in the top-right triangle are sorted in non-decreasing order.
//
// ------- Example 1 -------
// Input: grid = [[1,7,3],[9,8,2],[4,5,6]]
// Output: [[8,2,3],[9,6,7],[4,5,1]]
//
// ------- Example 2 -------
// Input: grid = [[0,1],[1,2]]
// Output: [[2,1],[1,0]]
//
// ------- Example 3 -------
// Input: grid = [[1]]
// Output: [[1]]
//
// ------- APPROACH -------
// 1. Traverse all diagonals starting from the bottom row (col=0) upward.
//    - Collect diagonal values, sort them, and put them back.
// 2. Traverse diagonals starting from top row (row=0, col=1..n-1).
//    - Collect diagonal values, sort them, and put them back.
// 3. Return the modified matrix.
//
// **** Time Complexity(TC): O(n^2 log n) *****
// (each diagonal sorted individually, total elements = n^2)
// **** Space Complexity(SC): O(n) *****
// (extra array for largest diagonal)
//
// ---------------- CODE ----------------

import java.util.Arrays;

class Solution {
    public int[][] sortMatrix(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int d = 1;

        // -------- Bottom-left diagonals (including main diagonal) --------
        for (int i = n - 1; i >= 0; i--) {
            int temp[] = new int[d];   // store diagonal values
            int a = i, b = 0, k = 0;

            // collect diagonal elements
            while (a < n && b < m) {
                temp[k++] = grid[a][b];
                a++;
                b++;
            }

            Arrays.sort(temp);  // sort diagonal

            // tricky part: here we go back and re-fill diagonal
            // (note: this version fills in reverse direction)
            a--; b--; k = 0;
            while (a >= 0 && b >= 0) {
                grid[a][b] = temp[k++];
                a--;
                b--;
            }
            d++;
        }

        d = n - 1;

        // -------- Top-right diagonals --------
        for (int i = 1; i < m; i++) {
            int temp[] = new int[d];
            int a = 0, b = i, k = 0;

            // collect diagonal elements
            while (a < n && b < m) {
                temp[k++] = grid[a][b];
                a++;
                b++;
            }

            Arrays.sort(temp);  // sort ascending

            // put sorted values back along diagonal
            a = 0; b = i; k = 0;
            while (a < n && b < m) {
                grid[a][b] = temp[k++];
                a++;
                b++;
            }
            d--;
        }
        return grid;
    }
}
