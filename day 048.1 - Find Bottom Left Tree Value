/**
 * Problem: Find Bottom Left Tree Value
 * 
 * Given the root of a binary tree, return the leftmost value in the last row of the tree.
 * 
 * Example:
 * Input: 
 *        2
 *       / \
 *      1   3
 * Output: 1
 * 
 * Input:
 *          1
 *         / \
 *        2   3
 *       /   / \
 *      4   5   6
 *         /
 *        7
 * Output: 7
 * 
 * Approach:
 * Use level-order traversal (BFS) to traverse the tree level by level.
 * For each level, the first node encountered is the leftmost node for that level.
 * Update the answer at the start of each level. At the end, the answer will be 
 * the leftmost node of the last row.
 * 
 * Time Complexity: O(N) where N is the number of nodes.
 * Space Complexity: O(W) where W is the maximum width of the tree (queue size).
 */

import java.util.*;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    public int findBottomLeftValue(TreeNode root) {
        int ans = root.val;
        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()) {
            int n = q.size();
            for(int i = 0; i < n; i++) {
                TreeNode x = q.poll();
                if(i == 0) ans = x.val; // first node of the current level
                if(x.left != null) q.add(x.left);
                if(x.right != null) q.add(x.right);
            }
        }
        
        return ans;
    }
}
