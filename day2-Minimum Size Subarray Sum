// QUESTION: leetcode:209
// Given an array of positive integers nums and a positive integer target, 
// return the minimal length of a subarray whose sum is greater than or equal to target. 
// If there is no such subarray, return 0 instead.
//
// Example 1:
// Input: target = 7, nums = [2,3,1,2,4,3]
// Output: 2
// Explanation: The subarray [4,3] has the minimal length under the problem constraint.
//
// ------- APPROACH -------
// We use the **sliding window** technique.
// 1. Keep expanding the right pointer and adding to the sum.
// 2. Once the sum >= target, shrink the window from the left while possible, 
//    and update the minimal length.
// 3. Continue until the right pointer reaches the end.
// This ensures every subarray is checked in O(n) time.
//
// **** Time Complexity(TC): O(n) *****
// **** Space Complexity(SC): O(1) *****


class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int l = 0, r = 0;   // window pointers
        int sum = 0;
        int ans = Integer.MAX_VALUE;

        while (r < n) {
            sum += nums[r];

            // shrink window as long as condition is satisfied
            while (sum >= target) {
                ans = Math.min(ans, r - l + 1);
                sum -= nums[l];
                l++;
            }
            r++;
        }

        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
