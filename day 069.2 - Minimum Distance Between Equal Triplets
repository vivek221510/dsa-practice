/*
ðŸ§© Problem: Minimum Distance Between Equal Triplets

You are given an integer array nums.
Find the minimum total distance between three equal elements (nums[i] == nums[j] == nums[k]) such that i < j < k.

The total distance is defined as:
    (j - i) + (k - j) + (k - i)

If no such triplet exists, return -1.

---------------------------------------------------------
ðŸ§  Example:

Input:
nums = [1, 2, 1, 2, 1]

Output:
6

Explanation:
Triplet of 1 occurs at indices (0, 2, 4)
Distance = (2 - 0) + (4 - 2) + (4 - 0) = 6
---------------------------------------------------------
âš™ï¸ Optimized Approach (Using HashMap):

1. Store indices of each number in a map.
2. For each value, retrieve its list of indices.
3. If there are at least 3 occurrences, compute distances for consecutive triplets.
4. Track and return the minimum distance.

---------------------------------------------------------
â±ï¸ Complexity Analysis:

Time Complexity:  O(n)
Space Complexity: O(n)
---------------------------------------------------------
*/

import java.util.*;

class Solution {
    public int minimumDistance(int[] nums) {
        int n = nums.length;
        Map<Integer, List<Integer>> map = new HashMap<>();
        int max = -1;

        // Step 1: Store all indices of each number
        for (int i = 0; i < n; i++) {
            max = Math.max(max, nums[i]);
            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);
        }

        int ans = Integer.MAX_VALUE;

        // Step 2: Check each number's list for triplets
        for (int i = 1; i <= max; i++) {
            if (map.containsKey(i)) {
                List<Integer> arr = map.get(i);
                int size = arr.size();
                if (size >= 3) {
                    int l = 0, j = 1, k = 2;
                    while (k < size) {
                        int dis = (arr.get(j) - arr.get(l)) + (arr.get(k) - arr.get(j)) + (arr.get(k) - arr.get(l));
                        ans = Math.min(ans, dis);
                        l++; j++; k++;
                    }
                }
            }
        }

        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}

/*
ðŸ§® Example Walkthrough:
nums = [3, 1, 3, 3]
Indices for 3 â†’ [0, 2, 3]
Distance = (2 - 0) + (3 - 2) + (3 - 0) = 6
Output = 6

---------------------------------------------------------
ðŸ Summary:
âœ”ï¸ Uses HashMap to reduce redundant triplet checks
âœ”ï¸ Efficient compared to brute-force (O(nÂ³))
âœ”ï¸ Works well for larger arrays
*/
