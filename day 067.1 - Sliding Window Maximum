/*
üß© Problem: Sliding Window Maximum

You are given an integer array nums and an integer k.
There is a sliding window of size k that moves from the left to the right of the array.
At each step, the window includes k elements from nums.
Return an array representing the maximum value in each sliding window.

Example:
Input:
nums = [1,3,-1,-3,5,3,6,7], k = 3
Output:
[3,3,5,5,6,7]

Explanation:
Window positions and maximums:
[1,3,-1] ‚Üí 3
[3,-1,-3] ‚Üí 3
[-1,-3,5] ‚Üí 5
[-3,5,3] ‚Üí 5
[5,3,6] ‚Üí 6
[3,6,7] ‚Üí 7

üß† Approach:
We use a Deque (Double-Ended Queue) to efficiently keep track of potential maximums for each window:
1. The deque stores indices, not values.
2. For each index i:
   - Remove elements from the front that are out of the current window.
   - Remove elements from the back if their value is smaller than the current number.
   - Add the current index to the back.
   - Once we reach index i ‚â• k - 1, record the maximum (value at the front of the deque).

‚è±Ô∏è Complexity Analysis:
Time Complexity:  O(n)   (each element added and removed at most once)
Space Complexity: O(k)   (deque stores at most k indices)
*/

import java.util.*;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int ans[] = new int[nums.length - k + 1];
        int ansIndex = 0;
        Deque<Integer> dq = new LinkedList<>();

        for (int i = 0; i < nums.length; i++) {
            // Remove elements that are out of this window
            while (!dq.isEmpty() && dq.peekFirst() <= i - k) {
                dq.pollFirst();
            }

            // Remove smaller elements from the back
            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {
                dq.pollLast();
            }

            // Add current element index
            dq.offerLast(i);

            // Store max for current window
            if (i >= k - 1) {
                ans[ansIndex++] = nums[dq.peekFirst()];
            }
        }
        return ans;
    }
}
