/*
 Minimum Operations to Equalize Array
Easy

You are given an integer array nums of length n.

In one operation, choose any subarray nums[l...r] (0 <= l <= r < n) and replace each element in that subarray 
with the bitwise AND of all elements.

Return the minimum number of operations required to make all elements of nums equal.

Example 1:
Input: nums = [1,2]
Output: 1
Explanation:
Choose nums[0...1]: (1 AND 2) = 0 â†’ array becomes [0, 0].

Example 2:
Input: nums = [5,5,5]
Output: 0
Explanation:
All elements are already equal.

Constraints:
- 1 <= nums.length <= 10^5
- 0 <= nums[i] <= 10^9
*/

class Solution {
    public int minOperations(int[] nums) {
        // Flag to check if all elements are already equal
        boolean val = true;

        // Iterate through adjacent pairs to check equality
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] != nums[i + 1]) {
                val = false;  // Found unequal pair
                break;
            }
        }

        // If all elements are equal, no operation needed (return 0)
        // Otherwise, 1 operation is sufficient
        return val ? 0 : 1;
    }
}

/*
Time Complexity (TC): O(n)
- Single pass through the array of length n.

Space Complexity (SC): O(1)
- Only a constant number of variables are used.
*/
